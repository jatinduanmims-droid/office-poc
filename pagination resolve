Fix pagination so all pages are available without changing:
- function names
- parameters
- routes
- response field names already used

Problem:
- UI only shows 2 pages instead of ~67
- total_records is incorrect or missing

Tasks:
1. Ensure backend runs a separate COUNT(*) query without pagination.
2. Ensure COUNT query uses the same filters as data query but NO OFFSET / FETCH.
3. Ensure total_records reflects the full dataset size.
4. Include total_records in the response consistently.
5. Ensure paginated data query has stable ORDER BY (EMAIL_RECEIVEDTIME DESC, ROW_ID DESC).
6. Ensure cached counts (if any) refresh correctly.

Do NOT:
- calculate total_records from len(data)
- apply pagination to COUNT query
- change function signatures

Goal:
- UI shows correct number of pages (67+)
- Page navigation works beyond page 2





step2
Fix pagination metadata so paginator shows all pages.

Current problem:
- UI only shows 2 pages even though >600 records exist
- Backend pagination works but total_records is wrong

Tasks:
1. Ensure COUNT(*) query:
   - does NOT use OFFSET / FETCH / LIMIT
   - uses the same WHERE filters as the data query
2. Ensure total_records is returned from SQL COUNT, not len(data)
3. Ensure response always includes:
   - total_records
   - page
   - page_size
4. Ensure ORDER BY is deterministic:
   - EMAIL_RECEIVEDTIME DESC
   - ROW_ID DESC
5. Do not cache paginated results as total count
6. Do not change function names, parameters, or routes

Goal:
- total_records reflects full dataset size
- paginator shows all pages (67+)
- page navigation beyond page 2 works consistently



step3
Improve backend pagination with deep observability and zero breaking changes.

ABSOLUTE RULES:
- Do NOT rename any function
- Do NOT rename parameters
- Do NOT change API routes
- Do NOT change response schema
- Do NOT add frontend changes
- Do NOT remove existing logic; only reorganize safely
- No caching logic in this change

PRIMARY GOAL:
Make pagination correct, fast, and fully debuggable.

IMPLEMENT THE FOLLOWING:

1. DATABASE-LEVEL PAGINATION
   - In read_ecatch_batch:
     offset = (page - 1) * page_size
   - Apply order_by, offset, limit directly on Email query
   - Do NOT paginate in Python

2. TOTAL COUNT
   - Fetch total email count separately using:
     total_count = db.query(Email).count()
   - This count must be independent of pagination

3. BATCH TBOSS FETCH
   - Extract ROW_IDs from paginated Email rows
   - Fetch all TBoss rows in ONE query using:
     TBoss.MASTER_ROW_ID.in_(row_ids)
   - Build a lookup map keyed by MASTER_ROW_ID

4. RESPONSE ASSEMBLY
   - Combine Email + TBoss using the lookup map
   - Preserve existing response fields EXACTLY
   - Do NOT alter field names or structure

5. ADD DEBUG LOGGING (MANDATORY)
   Add structured logs with:
   - page
   - page_size
   - offset
   - total_count
   - email_rows_fetched
   - unique_row_ids_count
   - tboss_rows_fetched
   - final_response_rows
   - execution_time_seconds

   Example log format:
   PAGE={page} SIZE={page_size} OFFSET={offset}
   TOTAL_EMAIL_COUNT={total_count}
   EMAIL_ROWS_FETCHED={len(emails)}
   EMAIL_ROW_IDS_UNIQUE={len(set(row_ids))}
   TBOSS_ROWS_FETCHED={len(tboss_rows)}
   FINAL_RESPONSE_ROWS={len(details_list)}
   EXEC_TIME={seconds}

6. SAFETY GUARANTEES
   - Each page returns exactly page_size rows unless last page
   - All pages 1..N must work
   - No partial or duplicate rows
   - Stable ordering across page navigation

EXPECTED OUTCOME:
- Pagination works beyond 2 pages
- Page size is always consistent
- Backend performance improves significantly
- Logs clearly explain any future issue in one glance

