Fix pagination so all pages are available without changing:
- function names
- parameters
- routes
- response field names already used

Problem:
- UI only shows 2 pages instead of ~67
- total_records is incorrect or missing

Tasks:
1. Ensure backend runs a separate COUNT(*) query without pagination.
2. Ensure COUNT query uses the same filters as data query but NO OFFSET / FETCH.
3. Ensure total_records reflects the full dataset size.
4. Include total_records in the response consistently.
5. Ensure paginated data query has stable ORDER BY (EMAIL_RECEIVEDTIME DESC, ROW_ID DESC).
6. Ensure cached counts (if any) refresh correctly.

Do NOT:
- calculate total_records from len(data)
- apply pagination to COUNT query
- change function signatures

Goal:
- UI shows correct number of pages (67+)
- Page navigation works beyond page 2





step2
Fix pagination metadata so paginator shows all pages.

Current problem:
- UI only shows 2 pages even though >600 records exist
- Backend pagination works but total_records is wrong

Tasks:
1. Ensure COUNT(*) query:
   - does NOT use OFFSET / FETCH / LIMIT
   - uses the same WHERE filters as the data query
2. Ensure total_records is returned from SQL COUNT, not len(data)
3. Ensure response always includes:
   - total_records
   - page
   - page_size
4. Ensure ORDER BY is deterministic:
   - EMAIL_RECEIVEDTIME DESC
   - ROW_ID DESC
5. Do not cache paginated results as total count
6. Do not change function names, parameters, or routes

Goal:
- total_records reflects full dataset size
- paginator shows all pages (67+)
- page navigation beyond page 2 works consistently



step3
Improve backend pagination with deep observability and zero breaking changes.

ABSOLUTE RULES:
- Do NOT rename any function
- Do NOT rename parameters
- Do NOT change API routes
- Do NOT change response schema
- Do NOT add frontend changes
- Do NOT remove existing logic; only reorganize safely
- No caching logic in this change

PRIMARY GOAL:
Make pagination correct, fast, and fully debuggable.

IMPLEMENT THE FOLLOWING:

1. DATABASE-LEVEL PAGINATION
   - In read_ecatch_batch:
     offset = (page - 1) * page_size
   - Apply order_by, offset, limit directly on Email query
   - Do NOT paginate in Python

2. TOTAL COUNT
   - Fetch total email count separately using:
     total_count = db.query(Email).count()
   - This count must be independent of pagination

3. BATCH TBOSS FETCH
   - Extract ROW_IDs from paginated Email rows
   - Fetch all TBoss rows in ONE query using:
     TBoss.MASTER_ROW_ID.in_(row_ids)
   - Build a lookup map keyed by MASTER_ROW_ID

4. RESPONSE ASSEMBLY
   - Combine Email + TBoss using the lookup map
   - Preserve existing response fields EXACTLY
   - Do NOT alter field names or structure

5. ADD DEBUG LOGGING (MANDATORY)
   Add structured logs with:
   - page
   - page_size
   - offset
   - total_count
   - email_rows_fetched
   - unique_row_ids_count
   - tboss_rows_fetched
   - final_response_rows
   - execution_time_seconds

   Example log format:
   PAGE={page} SIZE={page_size} OFFSET={offset}
   TOTAL_EMAIL_COUNT={total_count}
   EMAIL_ROWS_FETCHED={len(emails)}
   EMAIL_ROW_IDS_UNIQUE={len(set(row_ids))}
   TBOSS_ROWS_FETCHED={len(tboss_rows)}
   FINAL_RESPONSE_ROWS={len(details_list)}
   EXEC_TIME={seconds}

6. SAFETY GUARANTEES
   - Each page returns exactly page_size rows unless last page
   - All pages 1..N must work
   - No partial or duplicate rows
   - Stable ordering across page navigation

EXPECTED OUTCOME:
- Pagination works beyond 2 pages
- Page size is always consistent
- Backend performance improves significantly
- Logs clearly explain any future issue in one glance

step4 
Add permanent structured debug logging to backend APIs.

Rules:
- Do NOT change function names
- Do NOT change parameter names
- Do NOT change return structure
- Do NOT change business logic
- Only ADD logs
- Logs must stay permanently (not temporary debugging)

For each paginated API:
1. Log API entry with page and page_size
2. Log computed offset
3. Log total record count from DB
4. Log number of Email rows fetched
5. Log number of TBoss rows fetched
6. Log final response row count
7. Log execution time in seconds
8. Use consistent log prefix per API

Log format example:
DEBUG:<api_name>: PAGE={page} SIZE={page_size} OFFSET={offset}
DEBUG:<api_name>: TOTAL_COUNT={total}
DEBUG:<api_name>: EMAIL_ROWS_FETCHED={n}
DEBUG:<api_name>: TBOSS_ROWS_FETCHED={n}
DEBUG:<api_name>: FINAL_RESPONSE_ROWS={n}
DEBUG:<api_name>: EXEC_TIME={seconds}

Ensure logs print for every request, cache hit or miss.




step5

Fix pagination correctness and observability without changing any existing function names or parameter names.

Rules:
- Do NOT rename APIs
- Do NOT rename parameters (page, page_size)
- Do NOT change business logic
- Do NOT change SQL semantics
- You MAY wrap the response in an object

Backend tasks:
1. Ensure paginated APIs return BOTH:
   - data (current page rows)
   - total_count (full DB count, before pagination)

2. Log page, page_size, offset, total_count, and final rows for EVERY request.

3. Return response shape:
{
  "data": [...],
  "total_count": <int>,
  "page": <int>,
  "page_size": <int>
}

4. Keep caching logic intact.

5. Add INFO log:
INFO:<api>: page=X rows=Y total=Z

Goal:
- Frontend must be able to render correct number of pages
- Logs must clearly show when page changes

