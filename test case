Perfect ask. This is exactly how seniors validate a system before calling it ‚Äúdone‚Äù.

Below is a single, clean, copy-paste prompt you can give to Roo Code that forces it to audit end-to-end: backend ‚Üí API ‚Üí frontend ‚Üí UX ‚Üí performance ‚Üí safety.

No fluff. Very precise. ‚úÖ

‚∏ª

üîç FINAL SYSTEM VERIFICATION PROMPT (Backend ‚Üí Frontend)

SYSTEM AUDIT PROMPT ‚Äî FULL STACK VERIFICATION

Goal
Verify that the entire system (FastAPI backend + Oracle DB + Angular app-v2 frontend) is correctly implemented, stable, and production-ready.

‚∏ª

Part 1 ‚Äî Backend Validation (FastAPI)
	1.	List all dashboard-related endpoints and verify:
	‚Ä¢	Correct HTTP method
	‚Ä¢	Correct route path
	‚Ä¢	Tagged under "dashboard"
	2.	For each endpoint:
	‚Ä¢	Confirm it queries only Oracle views (no base tables)
	‚Ä¢	Confirm it uses existing DB helpers (get_analyticsdb_data, utils_trans_db.py)
	‚Ä¢	Confirm no raw DB credentials or connections are created inside routes
	3.	Validate request parameters:
	‚Ä¢	Pagination bounds enforced
	‚Ä¢	Sort field whitelist enforced
	‚Ä¢	Sort direction validated
	‚Ä¢	Date filters correctly applied using TRUNC()
	4.	Validate responses:
	‚Ä¢	Pydantic schema matches returned JSON
	‚Ä¢	Field names are consistent across endpoints
	‚Ä¢	Empty datasets return safe defaults (no crashes)
	5.	Error handling:
	‚Ä¢	Invalid inputs return HTTP 400
	‚Ä¢	No unhandled exceptions leak stack traces

‚∏ª

Part 2 ‚Äî API Contract Consistency
	1.	Cross-verify:
	‚Ä¢	KPI response schema ‚Üî KPI frontend consumption
	‚Ä¢	Trend response schema ‚Üî Chart inputs
	‚Ä¢	Table response schema ‚Üî MatTable bindings
	2.	Confirm:
	‚Ä¢	No frontend logic relies on hardcoded field names
	‚Ä¢	All API URLs are centralized (single service)

‚∏ª

Part 3 ‚Äî Frontend Architecture (Angular app-v2)
	1.	Confirm:
	‚Ä¢	src/app (legacy) is untouched
	‚Ä¢	All new UI exists only under src/app-v2
	‚Ä¢	Dashboard module is lazy loaded at /dashboard-v2
	2.	Validate module structure:
	‚Ä¢	dashboard-page acts as container only
	‚Ä¢	KPI cards, charts, and table are isolated components
	‚Ä¢	No API calls inside templates or constructors
	3.	Verify services:
	‚Ä¢	One API service for dashboard data
	‚Ä¢	One shared filter/state service
	‚Ä¢	No duplicated HTTP logic

‚∏ª

Part 4 ‚Äî Data Flow & State
	1.	Validate:
	‚Ä¢	Global date filter updates all widgets
	‚Ä¢	Pagination resets on filter change
	‚Ä¢	No redundant API calls on init
	2.	Confirm:
	‚Ä¢	All subscriptions are cleaned up
	‚Ä¢	OnPush change detection is used where possible

‚∏ª

Part 5 ‚Äî UX & Error States
	1.	Verify presence of:
	‚Ä¢	Loading skeletons (KPI, charts, table)
	‚Ä¢	Empty state messages (no data)
	‚Ä¢	Disabled UI during loading
	2.	Confirm:
	‚Ä¢	No console errors
	‚Ä¢	No flickering or layout shifts

‚∏ª

Part 6 ‚Äî Performance & Safety
	1.	Check:
	‚Ä¢	Debounced filters
	‚Ä¢	Cancelled in-flight requests on change
	‚Ä¢	No blocking operations on UI thread
	2.	Validate:
	‚Ä¢	API calls are paginated
	‚Ä¢	No full table scans triggered from UI
	‚Ä¢	No secrets exposed to frontend

‚∏ª

Final Output Required

Provide:
	‚Ä¢	‚úÖ Passed checks
	‚Ä¢	‚ùå Failed checks (with file + line reference)
	‚Ä¢	‚ö†Ô∏è Improvements (non-blocking)
	‚Ä¢	üöÄ Final readiness verdict:
	‚Ä¢	Prototype / Production-ready / Needs fixes

Do NOT modify code unless explicitly requested.

‚∏ª

üß† Why This Prompt Works

This forces Roo Code to:
	‚Ä¢	Read actual code, not assume
	‚Ä¢	Validate contracts, not vibes
	‚Ä¢	Think like backend + frontend + SRE
	‚Ä¢	Give you a go/no-go verdict

This is the exact checklist used in real production sign-offs.

If you want next:
	‚Ä¢	A one-page ‚Äúhow this dashboard works‚Äù doc
	‚Ä¢	A senior-level explanation for interviews
	‚Ä¢	A production deployment checklist

Just say the word.